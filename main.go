package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"reflect"
	// "go/ast"
	// "go/importer"
	// "go/parser"
	// "go/token"
	// "go/types"
)

// type Repository []struct {
// 	CacheMaxSeconds int64 `json:"cacheMaxSeconds"`
// 	CurrentTime     int64 `json:"currentTime"`
// 	Doc             struct {
// 		TropData struct {
// 			Two016 []struct {
// 				Active   bool   `json:"active"`
// 				Category string `json:"category"`
// 				Status   string `json:"status"`
// 				TropID   string `json:"tropId"`
// 				TropName string `json:"tropName"`
// 			} `json:"Two016"`
// 		} `json:"TropData"`
// 		TropHdr struct {
// 			TNum int64 `json:"tNum"`
// 		} `json:"tropHdr"`
// 	} `json:"doc"`
// 	GeneratedTime int64  `json:"generatedTime"`
// 	ID            string `json:"id"`
// 	Status        int64  `json:"status"`
// }

var (
	buffer bytes.Buffer
)

func describeStruct(s interface{}) {

	if reflect.ValueOf(s).Kind() == reflect.Slice {
		switch reflect.ValueOf(s).Type().Elem().Kind() {
		case reflect.Struct:

			iType := reflect.TypeOf(s).Elem()
			describeSlice(iType)

		default:
			describeSimpleType("!!! something wrong happens !!!")
		}

		return
	}

	iValue := reflect.ValueOf(s)
	iType := reflect.TypeOf(s)

	for i := 0; i < iType.NumField(); i++ {
		v := iValue.Field(i)

		switch v.Kind() {
		case reflect.Struct:
			buffer.WriteString(`"` + iType.Field(i).Name + `": &graphql.Field{
				Type: graphql.NewObject(graphql.ObjectConfig{
					Name: "` + iType.Field(i).Name + `",
					Fields: graphql.Fields{`)

			// describeSimpleType(iType.Field(i).Name, "struct", string(iType.Field(i).Tag))
			describeStruct(v.Interface())

			buffer.WriteString(`	},
      }),
    },`)
		case reflect.Slice:
			buffer.WriteString(`"` + iType.Field(i).Name + `": &graphql.Field{
				Type: graphql.NewList(graphql.NewObject(graphql.ObjectConfig{
					Name: "` + iType.Field(i).Name + `",
					Fields: graphql.Fields{`)

			// describeSimpleType(iType.Field(i).Name, "slice", string(iType.Field(i).Tag))
			describeStruct(v.Interface())

			buffer.WriteString(`	},
      })),
    },`)
		default:
			describeSimpleType(iType.Field(i).Name, iType.Field(i).Type.String(), string(iType.Field(i).Tag))
		}
	}
}

func describeSlice(iType reflect.Type) {

	for i := 0; i < iType.NumField(); i++ {

		switch iType.Field(i).Type.Kind() {
		case reflect.Struct:
			// fmt.Println("!!!", strings.Split(string(iType.Field(i).Tag), ":")[1])
			buffer.WriteString(`"` + iType.Field(i).Name + `": &graphql.Field{
				Type: graphql.NewObject(graphql.ObjectConfig{
					Name: "` + iType.Field(i).Name + `",
					Fields: graphql.Fields{`)

			describeSimpleType(iType.Field(i).Name, "struct", string(iType.Field(i).Tag))
			describeSlice(iType.Field(i).Type)
			buffer.WriteString(`},
      }),
    },`)
		case reflect.Slice:
			// if iType.Field(i).Type.Elem().Kind() == reflect.Struct {
			buffer.WriteString(`"` + iType.Field(i).Name + `": &graphql.Field{
				Type: graphql.NewList(graphql.NewObject(graphql.ObjectConfig{
					Name: "` + iType.Field(i).Name + `",
					Fields: graphql.Fields{`)
			describeSimpleType(iType.Field(i).Name, "slice", string(iType.Field(i).Tag))
			describeSlice(iType.Field(i).Type.Elem())
			buffer.WriteString(`},
      })),
    },`)
			// }
		default:
			describeSimpleType(iType.Field(i).Name, iType.Field(i).Type.String(), string(iType.Field(i).Tag))
		}
	}
}

func describeSimpleType(text ...interface{}) {
	var fieldName string = text[0].(string)
	// var fieldType string = text[1].(string)
	// var fieldTag string = strings.Split(text[2].(string), ":")[1]
	var out string = ""
	switch text[1] {
	case "string":
		out = `"` + fieldName + `": &graphql.Field{
        Type: graphql.String,
      },`
	case "bool":
		out = `"` + fieldName + `": &graphql.Field{
        Type: graphql.Boolean,
      },`
	case "int64":
		out = `"` + fieldName + `": &graphql.Field{
        Type: graphql.Int,
      },`
	case "int32":
		out = `"` + fieldName + `": &graphql.Field{
          Type: graphql.Int,
        },`
	case "int":
		out = `"` + fieldName + `": &graphql.Field{
            Type: graphql.Int,
          },`
	default:
		errors.New("!!! Error !!! no such format")
	}
	buffer.WriteString(out)
}

func getRootDescription(strct interface{}) {

	if reflect.TypeOf(strct).Kind() == reflect.Struct {
		buffer.WriteString("// Generated by struct2gql-generator\n")
		buffer.WriteString(reflect.TypeOf(strct).Name() + `GqlType := graphql.NewObject(graphql.ObjectConfig{
		  Name: "` + reflect.TypeOf(strct).Name() + `",
		  Fields: graphql.Fields{`)

		describeStruct(strct)

		buffer.WriteString(`},
	  })`)
	}

	if reflect.TypeOf(strct).Kind() == reflect.Slice {
		buffer.WriteString("// Generated by struct2gql-generator\n")
		buffer.WriteString(reflect.TypeOf(strct).Name() + `GqlType := graphql.NewList(graphql.NewObject(graphql.ObjectConfig{
		  Name: "` + reflect.TypeOf(strct).Name() + `",
		  Fields: graphql.Fields{`)

		describeStruct(strct)

		buffer.WriteString(`},
}))`)
	}
}
func main() {

	// getRootDescription(Repository{})
	// fmt.Println(buffer.String())

	parseStructFile()
	fmt.Println(buffer.String())
}

func parseStructFile() {
	srcBytes, _ := ioutil.ReadFile("struct.go")
	src := string(srcBytes)
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "", src, 0)
	if err != nil {
		fmt.Println(err)
		return
	}

	// conf := types.Config{Importer: importer.Default()}
	// pkg, err := conf.Check("", fset, []*ast.File{f}, nil)
	// if err != nil {
	// 	fmt.Println(err) // type error
	// }
	// for _, name := range pkg.Scope().Names() {
	// 	fmt.Printf("%#v\n", pkg.Scope().Lookup(name).(*types.TypeName).Name())
	// 	fmt.Printf("%#v\n", pkg.Scope().Lookup(name).(*types.TypeName).Type().Underlying())
	// 	switch pkg.Scope().Lookup(name).(*types.TypeName).Type().Underlying().(type) {
	// 	case *types.Struct:
	// 		fmt.Printf("%#v", unsafe.Pointer(types.NewPointer(pkg.Scope().Lookup(name).(*types.TypeName).Type().(*types.Named))))
	// 	}
	// 	// if obj, ok := pkg.Scope().Lookup(name).(*types.TypeName); ok {
	// 	// 	fmt.Printf("%v\n", obj.Type().(*types.Named))
	// 	// }
	// }

	for decl := range f.Decls {

		typeDecl := f.Decls[decl].(*ast.GenDecl)
		switch typeDecl.Specs[0].(*ast.TypeSpec).Type.(type) {
		case *ast.StructType:
			fmt.Println("StructType")
			start := typeDecl.Specs[0].(*ast.TypeSpec).Pos() - 1
			end := typeDecl.Specs[0].(*ast.TypeSpec).Type.End() - 1
			source := string(srcBytes[start:end])
			fmt.Printf("%#v\n", source)
			// case *ast.ArrayType:
			// 	fmt.Println("ArrayType")
			// 	start := typeDecl.Specs[0].(*ast.TypeSpec).Pos() - 1
			// 	end := typeDecl.Specs[0].(*ast.TypeSpec).Type.End() - 1
			// 	fmt.Println(string(srcBytes[start:end]))
		}
	}

	// var conf loader.Config
	// conf.CreateFromFilenames("main", "structs/structs.go")
	// conf.Import("struct-to-graphql/structs")
	// // conf.ImportWithTests("fmt")
	// prog, _ := conf.Load()
	// // if err != nil {
	// // 	fmt.Println(err)
	// // }
	// if prog != nil {
	// 	for p := range prog.AllPackages {
	// 		fmt.Println(p)
	// 	}
	// }

}
